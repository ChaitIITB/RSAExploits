# Project Writeup
###Problem domain
Cryptography challenges are popular in Capture the Flag (CTF) competitions and many of them involve exploiting a vulnerability in a poorly implemented RSA cryptosystem. These vulnerabilities make it possible to either factor an RSA modulus in a reasonable amount of time or compute the plaintext message directly.  Often the workflow for solving one these RSA problems involves figuring out which vulnerability is present, researching exploits for that vulnerability, and writing a program/script implementing an exploit. Assuming that the vulnerability is not revealed in the problem statement, each of these steps can take a significant amount of time. On top of that there is also the time spent debugging the exploit implementation.  

To help reduce the amount of time spent on each of these steps, we have developed an RSA vulnerabilities exploit library for CTF challenges related to RSA cryptosystems. Many commonly known exploits including Wiener's Attack, Hastad's Broadcast Attack, Common Modulus attack are already implemented for the user. In addition, various prime factorization methods each with their own special use cases are included. If the required exploit is already implemented by our library, the time required to research, code, and debug a solution is significantly reduced. If the RSA vulnerability or required exploit is not immediately known, a user could run a battery of exploits against the provided ciphertexts and RSA key data in an attempt to uncover more information. The library can also be used to test CTF challenges for correctness, thus reducing the amount time required to implement solution scripts. 

###CTF Problem examples:

CTF Problem: Hack You 2014 - CRYPTONET:
We have intercepted communication in a private network. It uses a strange protocol based on RSA cryptosystem.
Can you still prove that it is not secure enough and get the flag?

Analysis of server RSA implementation and capture file:
* Integer encoded plain-text message is less than modulus
* Public exponent(e) remains constant (17), but modulus(N) varies
* 19 ciphertexts are captured

This cryptosystem is vulnerable to Hastad's Broadcast Attack. Hastad's attack uses the Chinese Remainder Theorem to recover the plaintext message given a list of ciphertexts, moduli, and the public exponent e. It is guaranteed to succeed if the same plaintext message was used to generate all ciphertexts, the public exponent e is the same in all encryptions, the number of ciphertexts is greater than or equal to e, all of the moduli are greater than the plaintext, all of the moduli are unique, and all of the moduli are coprime (if they are not coprime then they share a common factor and another exploit can be used). Ideally, all a user of our library would need to do for this problem is extract the ciphertexts, moduli, and public exponent from the packet capture and provide that information to our library. Our library would run through a list of exploits that includes Hastad's attack and would recover the plaintext. If the user realizes that the correct exploit is Hastad's attack, they could specify the correct exploit and not have to wait for all of the other exploits to finish executing.


```
import RSAExploits

rsadata_list = []
for i in range(0, 19)
rsadata_list.append(RSA_Data((N[i],e[i]), (c[i], idnum=1)))
if Hastad().run(rsadata_list):
	flag = hex2string(rsadata_list.get_m())
	if is_printable(flag):
		print "Decrypted text: ", flag
	else:
		print "Decrypted text is not printable."
```

####CTF Problem: Hack.lu 2014 - Wiener:
It’s gold rush time! The New York Herald just reported about the Californian gold rush. We know a sheriff there is hiring guys to help him fill his own pockets. We know he already has a dreadful amount of gold in his secret vault. However, it is protected by a secret only he knows. When new deputies apply for the job, they get their own secret, but that only provies entry to a vault of all deputy sheriffs. No idiot would store their stuff in this vault. But maybe we can find a way to gain access to the sheriff’s vault? Have a go at it:
nc wildwildweb.fluxfingers.net 1426

Analysis of server RSA implementation:
* Public key is accessible through server
* The size of the private exponent(d) in bits is around 1/5 of the modulus

The name of the problem gives it away, but this cryptosystem is vulnerable to Wiener's Attack. Wiener's attack is able to recover the private exponent d when d < N^(1/4). Once again, our library could be used to reduce the amount of time needed to write a script that uses Wiener's attack to recover the private key and decrypt the message. 

```
import RSAExploits
rsadata = RSA_Data((N,e), (c))
if Wiener.run([rsadata]):
	plaintext = rsadata.decrypt()
	flag = hex2string(plaintext)
	if is_printable(flag):
		print "Decrypted text: ", flag
	else:
		print "Decrypted text is not printable."
else:
	print "Wiener Attack can't be executed!"
```

###Existing Research/Work
##### 1. Twenty Years of Attacks on the RSA Cryptosystem
This paper provides a survey of many potential vulnerabilities in the RSA cryptosystem and describes exploits for each. Among the discussed exploits are common modulus, Wiener's attack, Boneh Durfee attack, Hastad's Broadcast atack, and Franklin-Reiter Related Message attack. We used this paper as a basis for determining which exploits to include in our library. 
#####2. https://github.com/pablocelayes/rsa-wiener-attack
Github user pablocelayes has written a collection of python scripts that implement Wiener's
attack on RSA. When the private exponent(d) is less than N^(1/4), Wiener's attack can use continued fraction approximations to recover d.
#####3 https://github.com/mimoo/RSA-and-LLL-attacks
Github user mimoo appears to have written a collection of sage scripts that implement LLL
lattice based attacks on RSA. LLL lattice reduction is an algorithm created by Coppersmith
that can be used for finding roots of polynomial equations. His implementation of Boneh Durfee's attack is included in out library.
#####4 http://ahack.ru/write-ups/ructf-quals-14.htm
User Black Fan provided a implementation of the Franklin-Reiter Related Message attack that we modified to be more general.

###Our Work (Delta)
##### Introduction
During our research, we were unable to find a single library or tool that presented RSA exploits in coherent and easy to use fashion. We did find many implementations of RSA exploits that various CTF competitors around the world had posted in their writeups. However, many of them were coded in such a way that they were specific to the problem being solved and could not be applied to other problems. Of the implentations that were coded to be more general, they often required different paramters and it was unlikely that implentations for two different exploits would provide the same interface. To solve these issues, we designed to develop a library that provided both general implementations of various exploits for RSA vulnerabilities and an a simple uniform interface through which these exploits could be run. 

##### Architecture
We implemented a class called RSA_Data to store all of the information associated with a particular ciphertext/plaintext and the RSA keys/parameters used to manipulate that text data. At the moment, RSA_Data is implemented as a combination of the RSAObj class from pycrypto and a simple Text_Data class that we implemented ourselves. The RSAObj class is used to store all of the RSA key data. This includes the modulus N, public exponent e, private exponent d, and prime modulus factors p and q. We leveraged RSAObj's preexisting functionality for encryption and decryption. The Text_Data class stores the ciphertext, plaintext, and an ID number. Some of the exploits in our library only work if all ciphertexts were generated from the same plaintext. Text_Data objects with the same ID number contain ciphertexts that were generated from the same plaintext. The ID number field must be set by the user. 

Each exploit is implemented as a class that extends a base Exploit class. The base Exploit class only exports one method (plus the initializer) called run that takes 2 parameters. The first parameter is a list of RSA_Data objects and the second is a dictionary that can be used to specify additional information for particular exploits. For example, the Franklin-Reiter exploit requires a polynomial that specifies the relationship between 2 plaintext messages that were used to generate known ciphertexts. The presence of the run method provides a common interface that a user can use to call any exploit after the list of RSA_Data objects has been populated. Extracting the required information from the RSA_Data objects is handled by the run function and any subroutines called from there. 

##### Usage
We envision the common workflow as follows. First, the user will initialize a list of RSAData objects using information from the problem. Initializing an RSAData object reqires first initializing an RSAObj and a Text_Data object. The RSAObj should be initialized using our RSAObj function which is actually a wrapper for pycrypto's construct function. The parameters to this function are as follows:

n: RSA modulus
e: public exponent
d: private exponent
p: first prime factor
q: second prime factor

All of the above parameters are longs!

n and e are required parameters while the others are optional. We expect that in most CTF problems, the user will only provide n and e. 

The parameters to the Text_Data initializer are as follows

c: ciphertext
m: plaintext
idnum: ID number used to specify which ciphertexts were generated from the same plaintext

All of the above parameters have an integer type (they don't have to be explicitly declared as longs).

None of these parameters are required and even the Text_Data object itself is an optional parameter in the initializer for the RSAData object. However, many exploits require that ciphertexts are provided and so a user would most often provide values for c and idnum.



c: ciphertext 

##### Expansion


##### Sage


###Problem Demo
