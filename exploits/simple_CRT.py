from fractions import gcd
from common_rsa_functions import egcd as egcd
from common_rsa_functions import modinv as modinv
from RSAObject import RSAObject

# Find the kth root of n
def iroot(k, n):
    u, s = n, n+1
    while u < s:
        s = u
        t = (k-1) * s + n // pow(s, k-1)
        u = t // k
    return s


def chinese_remainder_theorem(ciphertexts):
    """Solve the chinese remainder theorem

    Given a list of items (a_i, n_i) solve for x such that x = a_i (mod n_i)
    such that 0 <= x < product(n_i)

    Assumes that n_i are pairwise co-prime.
    """

    # Determine N, the product of all n_i
    N = 1
    for ciphertext in ciphertexts:
        N *= RSAObject.get_modulus(ciphertext)

    # Find the solution (mod N)
    result = 0
    for ciphertext in ciphertexts:
        n = RSAObject.get_modulus(ciphertext)
        a = RSAObject.get_ciphertext(ciphertext)
        m = N//n
        d, s, r = egcd(m, n)
        if d != 1:
            raise "Input not pairwise co-prime"
        result += a*s*m

    # Make sure we return the canonical solution.
    return result % N


# Check for the presence of Chinese Remainder Theorem exploit within the ciphertexts
def attack(rsa_object):
    exponent_dictionary = {}
    print "Simple CRT Test"
    if not rsa_object.identical_messages:
        print "Exiting because not all ciphertexts were generated from the same message"
        print "------------------------------------------------------------------------"
        return
    
    for ciphertext in rsa_object.ciphertexts:
        if RSAObject.get_exponent(ciphertext) in exponent_dictionary:
            exponent_dictionary[RSAObject.get_exponent(ciphertext)].append(ciphertext)
        else:
            exponent_dictionary[RSAObject.get_exponent(ciphertext)] = [ciphertext]

    for key in exponent_dictionary:
        if len(exponent_dictionary[key]) > 1:
            print "Common Exponents Found"
            break
    else:
        print "No Common Exponents Found"
    for key in exponent_dictionary:
        if len(exponent_dictionary[key]) > 1:
            CRT_exploit(exponent_dictionary[key])

# Assumes that all moduli in the provided list are relatively prime
def CRT_exploit(ciphertexts):

    num_texts = len(ciphertexts)
    exponent = RSAObject.get_exponent(ciphertexts[0])
    print str(num_texts) + " ciphertexts are using public exponent: " + str(exponent)

    result = chinese_remainder_theorem(ciphertexts)
    print "Attempt to recover plaintext: " + str(hex(iroot(exponent,result)))


