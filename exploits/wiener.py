#!/usr/bin/python

import re
import math
from sympy.solvers import solve
from sympy.core.numbers import Integer
from sympy import *
from sympy import invert
from fractions import gcd
from Exploit import Exploit
from RSAExploits.util import modInv

class wiener(Exploit):
	roots = []
	rsadataset = []
	found = None
	n = None; e = None; d = None; p = None; q = None; psi = None;
	def run(self, rsadata):
		print ("Wiener: Running Attack...")
		
		if type (rsadata) is not list:
			self.rsadataset.append(rsadata)
		else:
			self.rsadataset = list(rsadata)

		for rdata in self.rsadataset:
			self.n = rdata.rsaobj.n
			self.e = rdata.rsaobj.e 
			self.roots = self.execute(self.n,self.e)
			if self.roots != None:
				self.p, self.q = self.roots
				rdata.rsaobj.p = self.p 
				rdata.rsaobj.q = self.q
				self.psi = (self.p-1)*(self.q-1)
				self.d = modInv(self.e, self.psi)
				rdata.rsaobj.d = long(int(self.d))
				rdata.setD(rdata.rsaobj.d)
				if rdata.txt.c != None:
					rdata.decrypt()
				self.found = 1
			self.n = None; self.e = None; self.d = None; self.p = None; self.q = None; self.psi = None;
		if self.found != None:		
			print("Wiener: Success, roots found, assigned in rsadata.")
			return True							
		else: 			
			print("Wiener: Failure, roots not found.")
			return False


	def check(self, rsadata):
		print ("Wiener: Checking Attack...")
		if self.execute(rsadata.rsaobj.n, rsadata.rsaobj.e) != None:
			return True
		else:
			return False	

	@staticmethod
	def conFraction(fraction):
	    (a,b) = fraction
	    v=[]
	    v.append(0)
	    while not a == 1:
			(x,y) = fraction
			try:
				r =  y / x
				a = y % x
			except ZeroDivisionError as details:
				print ("Exception occured:",details)
			 	print("Continuing to next RSA data...")
				return None
			b=x
			fraction = (a,b)
			v.append(r)
	    v.append(b)
	    return v

	@staticmethod
	def makeIndexedConvergent(sequence, index):
	    (a,b)=(1,sequence[index])
	    while index>0:
		index-=1
		(a,b)=(b,sequence[index]*b+a)
	    return (b,a)

	@staticmethod
	def makeConvergents(sequence):
	    r=[]
	    for i in xrange(0,len(sequence)):
		r.append(wiener.makeIndexedConvergent(sequence,i))
	    return r

	@staticmethod
	def execute(N,e):
		v = wiener.conFraction((e,N))
		if v is None:
			return None
		conv = wiener.makeConvergents(v)
 		for frac in conv:
			(k,d)=frac
			if k == 0:
				continue
			phiN=((e*d)-1)/k
			if ((pow(N-phiN+1, 2) - 4*N) <= 0 ): # (b^2 -4ac) <= 0 
				continue
				# solving equation (a**2 + b*x + c)
			x = Symbol('x', integer=True)
			roots = []
			roots = solve(x**2 -(N-phiN+1)*x + N, x, rational=False)
	 
			if len(roots) == 2:
				if type(roots[0]) is Integer and type(roots[0]) is Integer:
						     
					if(roots[0]*roots[1] == N):
						return roots
		 

