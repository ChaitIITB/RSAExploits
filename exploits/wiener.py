#!/usr/bin/python

import re
import math
from sympy.solvers import solve
from sympy import Symbol
from sympy import invert
from fractions import gcd
import binascii

def conFraction(fraction):
    (a,b) = fraction
    v=[]
    v.append(0)
    while not a == 1:
        (x,y) = fraction
        r=y/x
        a=y%x
        b=x
        fraction = (a,b)
        v.append(r)
    v.append(b)
    return v

def makeIndexedConvergent(sequence, index):
    (a,b)=(1,sequence[index])
    while index>0:
        index-=1
        (a,b)=(b,sequence[index]*b+a)
    return (b,a)

def makeConvergents(sequence):
    r=[]
    for i in xrange(0,len(sequence)):
        r.append(makeIndexedConvergent(sequence,i))
    return r

def execute(N,e):
    conv=makeConvergents(conFraction((e,N)))
    for frac in conv:
        (k,d)=frac
        if k == 0:
            continue
        phiN=((e*d)-1)/k
        if ((pow(N-phiN+1, 2) - 4*N) <= 0 ): # (b^2 -4ac) <= 0 
            continue
		# solving equation (a**2 + b*x + c)
        x = Symbol('x')
        roots=solve(x**2 -(N-phiN+1)*x + N, x, rational=False) 
        if len(roots) == 2:
			# integer roots check
            p,q=roots[0]%N,roots[1]%N
            if(p*q==N):
                return p, q
def check(N,e):
	if execute(N,e) != None:
		return True
	else:
		return False 

def decrypt(N, d, msg):
#	print msg
	ci = int((msg), 0)
	pt = pow(ci, d, N)	 
	ptx = hex(pt)
#	print ptx
	if len(str(ptx)[2:-1]) % 2 != 0:
		ptx1 = '0' + str(ptx)[2:-1]
	else:
		ptx1 = str(ptx)[2:-1]
	ptc = binascii.unhexlify(ptx1)
	print ptc
