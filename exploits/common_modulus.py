from fractions import gcd
from common_rsa_functions import egcd as egcd
from common_rsa_functions import modinv as modinv
from RSAObject import RSAObject

# Create a dictionary of ciphertexts keyed by the modulus
# used to encrypt them
def group_ciphertexts_by_moduli(ciphertexts):
    
    modulus_dictionary = {}
    
    for ciphertext in ciphertexts:
        if ciphertext.rsa.n in modulus_dictionary:
            modulus_dictionary[ciphertext.rsa.n].append(ciphertext)
        else:
            modulus_dictionary[ciphertext.rsa.n] = [ciphertext]

    return modulus_dictionary

# Returns True if n1 and n2 are coprime and False otherwise
def coprime(n1, n2):
    return gcd(n1, n2) == 1


# Attempt to decrypt a ciphertext using the common modulus exploit
def common_modulus_exploit(ciphertext1, ciphertext2):

    if ciphertext1.rsa.n != ciphertext2.rsa.n:
	return None
    if not coprime(ciphertext1.rsa.e, ciphertext2.rsa.e):
        return None

    N = ciphertext2.rsa.n
    c1 = ciphertext1.c
    c2 = ciphertext2.c   
 
    # Because gcd(e1, e2) = 1, we know that there must exist two integers
    # X, Y such that Xe1 + Ye2 = 1. The values of X and Y can be computed
    # using the Extended Euclidean algorithm
    g,x,y = egcd(ciphertext1.rsa.e, ciphertext2.rsa.e)

    # If either x or y is negative, we need to compute the multiplicative
    # modular inverse of the corresponding ciphertext and negate x/y.
    # c1 ^ -a = c1* ^ a where c1* is the multiplicative modular inverse of c1.
    if x < 0:
        x = -x
        c1 = modinv(c1, N)

    if y < 0:
        y = -y
        c2 = modinv(c2, N)

    # Compute (c1^ x * c2 ^ y) mod N    
    plaintext = (pow(c1, x, N) * pow(c2, y, N)) % N

    return plaintext
    


