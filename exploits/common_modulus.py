from fractions import gcd

CIPHERTEXT = 0
EXPONENT = 1
MODULUS = 2

# Extended Euclidean algorithm
def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)
    
# Returns the modular multiplicative inverse of (a mod m)
def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m

# Check for the presence of common modulus vulnerability within the ciphertexts
def common_modulus(rsa_object):
    print "Common Modulus Test"
    if not rsa_object.identical_messages:
        return
    modulus_dictionary = {}
    for ciphertext in rsa_object.ciphertexts:
        if ciphertext[2] in modulus_dictionary:
            modulus_dictionary[ciphertext[MODULUS]].append(ciphertext)
        else:
            modulus_dictionary[ciphertext[MODULUS]] = [ciphertext]

    if len(modulus_dictionary.keys()):
        print "Common Moduli Found"
    else:
        print "No Common Moduli Found"
    for key in modulus_dictionary:
        common_modulus_exploit(modulus_dictionary[key])

# Attempt to decrypt a ciphertext using the common modulus exploit
# "ciphertexts" is assumed to be a list of ciphertexts using the same
# modulus and plaintext
def common_modulus_exploit(ciphertexts):

    N = ciphertexts[0][MODULUS]
    
    # Find two values of e that are relatively prime
    e1_idx = None
    e2_idx = None
    for i in range(0, len(ciphertexts)):
        for j in range(i + 1, len(ciphertexts)):
            if gcd(ciphertexts[i][EXPONENT], ciphertexts[j][EXPONENT]) == 1:
                e1_idx = i
                e2_idx = j
                break

    if e1_idx == None:
        return

    # Because gcd(e1, e2) = 1, we know that there must exist two integers
    # X, Y such that Xe1 + Ye2 = 1. The values of X and Y can be computed
    # using the Extended Euclidean algorithm
    g,x,y = egcd(ciphertexts[e1_idx][EXPONENT], ciphertexts[e2_idx][EXPONENT])

    # Obtain the ciphertexts corresponding to the two public exponents
    c1 = ciphertexts[e1_idx][CIPHERTEXT]
    c2 = ciphertexts[e2_idx][CIPHERTEXT]

    # If either x or y is negative, we need to compute the multiplicative
    # modular inverse of the corresponding ciphertext and negate x/y.
    # c1 ^ -a = c1* ^ a where c1* is the multiplicative modular inverse of c1.
    if x < 0:
        x = -x
        c1 = modinv(c1, N)

    if y < 0:
        y = -y
        c2 = modinv(c2, N)

    # Compute (c1^ x * c2 ^ y) mod N    
    plaintext = (pow(c1, x, N) * pow(c2, y, N)) % N

    # Decode the hex string
    plaintext = hex(plaintext)[2:-1]
    print "Decrypted message: " + plaintext.decode('hex')

'''
# Check if any of the moduli have common prime factors
def common_factors(self):
    print "Common Moduli Factors Test"
    for i in range(0, len(self.ciphertexts)):
        for j in range(i + 1, len(self.ciphertexts)):
            if(self.ciphertexts[i][MODULUS] == self.ciphertexts[j][MODULUS]):
                continue
            if gcd(self.ciphertexts[i][MODULUS], self.ciphertexts[j][MODULUS]) != 1:
                print "Common Factor Found"
                '''

