from Exploit import Exploit
from fractions import gcd
from common_rsa_functions import egcd as egcd
from common_rsa_functions import modinv as modinv
from RSAObject import RSAObject

# Returns True if n1 and n2 are coprime and False otherwise
def coprime(n1, n2):
    return gcd(n1, n2) == 1

class Common_Modulus(Exploit):

    def run(self, ciphertexts):
        decrypted_ciphertexts = set([])
        modulus_dictionary = self.group_ciphertexts_by_moduli(ciphertexts)
         
        for key in modulus_dictionary:
            for i in range(0, len(modulus_dictionary[key]) - 1):
                for j in range(1, len(modulus_dictionary[key])):
                    
                    if self.common_modulus_exploit(modulus_dictionary[key][i], modulus_dictionary[key][j]):
                        decrypted_ciphertexts.add(modulus_dictionary[key][i])
                        decrypted_ciphertexts.add(modulus_dictionary[key][j])
        return decrypted_ciphertexts


    # Create a dictionary of ciphertexts keyed by the modulus
    # used to encrypt them
    @staticmethod
    def group_ciphertexts_by_moduli(ciphertexts):
        
        modulus_dictionary = {}
        
        for ciphertext in ciphertexts:
            if ciphertext.rsaobj.n in modulus_dictionary:
                modulus_dictionary[ciphertext.getN()].append(ciphertext)
            else:
                modulus_dictionary[ciphertext.getN()] = [ciphertext]

        return modulus_dictionary



    # Attempt to decrypt a ciphertext using the common modulus exploit
    @staticmethod
    def common_modulus_exploit(ciphertext1, ciphertext2):

        if ciphertext1.rsaobj.n != ciphertext2.getN():
            return False
        if not coprime(ciphertext1.getE(), ciphertext2.getE()):
            return False

        N = ciphertext2.getN()
        c1 = ciphertext1.getC()
        c2 = ciphertext2.getC()  
     
        # Because gcd(e1, e2) = 1, we know that there must exist two integers
        # X, Y such that Xe1 + Ye2 = 1. The values of X and Y can be computed
        # using the Extended Euclidean algorithm
        g,x,y = egcd(ciphertext1.getE(), ciphertext2.getE())

        # If either x or y is negative, we need to compute the multiplicative
        # modular inverse of the corresponding ciphertext and negate x/y.
        # c1 ^ -a = c1* ^ a where c1* is the multiplicative modular inverse of c1.
        if x < 0:
            x = -x
            c1 = modinv(c1, N)

        if y < 0:
            y = -y
            c2 = modinv(c2, N)

        # Compute (c1^ x * c2 ^ y) mod N    
        plaintext = (pow(c1, x, N) * pow(c2, y, N)) % N
        ciphertext1.setM(plaintext)
        ciphertext2.setM(plaintext)
        return True
        


