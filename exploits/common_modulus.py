from fractions import gcd
from common_rsa_functions import egcd as egcd
from common_rsa_functions import modinv as modinv
from RSAObject import RSAObject

# Check for the presence of common modulus vulnerability within the ciphertexts
def attack(rsa_object):
    print "Common Modulus Test"
    if not rsa_object.identical_messages:
        print "Exiting because not all ciphertexts were generated from the same message"
        print "------------------------------------------------------------------------"
        return
    modulus_dictionary = {}
    for ciphertext in rsa_object.ciphertexts:
        if RSAObject.get_modulus(ciphertext) in modulus_dictionary:
            modulus_dictionary[RSAObject.get_modulus(ciphertext)].append(ciphertext)
        else:
            modulus_dictionary[RSAObject.get_modulus(ciphertext)] = [ciphertext]


    for key in modulus_dictionary:
        if len(modulus_dictionary[key]) > 1:
            print "Common Moduli Found"
            break
    else:
        print "No Common Moduli Found"
        print "------------------------------------------------------------------------"
        return
    for key in modulus_dictionary:
        common_modulus_exploit(modulus_dictionary[key])
    print "------------------------------------------------------------------------"

# Attempt to decrypt a ciphertext using the common modulus exploit
# "ciphertexts" is assumed to be a list of ciphertexts using the same
# modulus and plaintext
def common_modulus_exploit(ciphertexts):

    N = RSAObject.get_modulus(ciphertexts[0])
    
    # Find two values of e that are relatively prime
    e1_idx = None
    e2_idx = None
    for i in range(0, len(ciphertexts)):
        for j in range(i + 1, len(ciphertexts)):
            if gcd(RSAObject.get_exponent(ciphertexts[i]), RSAObject.get_exponent(ciphertexts[j])) == 1:
                e1_idx = i
                e2_idx = j
                break

    if e1_idx == None:
        return

    # Because gcd(e1, e2) = 1, we know that there must exist two integers
    # X, Y such that Xe1 + Ye2 = 1. The values of X and Y can be computed
    # using the Extended Euclidean algorithm
    g,x,y = egcd(RSAObject.get_exponent(ciphertexts[e1_idx]), RSAObject.get_exponent(ciphertexts[e2_idx]))

    # Obtain the ciphertexts corresponding to the two public exponents
    c1 = RSAObject.get_ciphertext(ciphertexts[e1_idx])
    c2 = RSAObject.get_ciphertext(ciphertexts[e2_idx])

    # If either x or y is negative, we need to compute the multiplicative
    # modular inverse of the corresponding ciphertext and negate x/y.
    # c1 ^ -a = c1* ^ a where c1* is the multiplicative modular inverse of c1.
    if x < 0:
        x = -x
        c1 = modinv(c1, N)

    if y < 0:
        y = -y
        c2 = modinv(c2, N)

    # Compute (c1^ x * c2 ^ y) mod N    
    plaintext = (pow(c1, x, N) * pow(c2, y, N)) % N

    # Decode the hex string
    plaintext = hex(plaintext)[2:-1]
    print "Decrypted message: " + plaintext.decode('hex')


