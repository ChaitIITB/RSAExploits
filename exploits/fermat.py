#!/usr/bin/env python

from sympy import integer_nthroot
from Exploit import Exploit
from RSAExploits.util import modInv

class fermat(Exploit):
	roots = []
	rsadataset = []
	found = None
	n = None; e = None; d = None; p = None; q = None; psi = None;
	def run(self, rsadata):
		print ("Fermat: Running Attack...")
		if type (rsadata) is not list:
			self.rsadataset.append(rsadata)
		else:
			self.rsadataset = list(rsadata)

		for rdata in self.rsadataset:
			self.n = rdata.rsaobj.n
			self.e = rdata.rsaobj.e 	
			self.roots = self.execute(self.n)
			if self.roots != None:
				self.p, self.q = self.roots
				rdata.rsaobj.p = self.p 
				rdata.rsaobj.q = self.q
				self.psi = (self.p-1)*(self.q-1)
				self.d = modInv(self.e, self.psi)
				rdata.rsaobj.d = long(int(self.d))
				rdata.setD(rdata.rsaobj.d)
				if rdata.txt.c != None:
					rdata.decrypt()
				self.found = 1
			self.n = None; self.e = None; self.d = None; self.p = None; self.q = None; self.psi = None;
		if self.found != None:		
			print("Fermat: Success, roots found, assigned in rsadata.")
			return True							
		else: 			
			print("Fermat: Failure, roots not found.")
			return False
	
	
	@staticmethod	
	def execute(n):
		limit=10000000
		a, exact = integer_nthroot(n, 2)
		max = a + limit
		while a < max:
			b2 = a*a - n
			if b2 >= 0:
				b, exact = integer_nthroot(b2, 2)
				if b != None:
					if b*b == b2:
						break
			a += 1
		if a < max:
			p = a+b
			q = a-b
			return p, q
		else:
			return None

        

