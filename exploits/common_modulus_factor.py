from common_rsa_functions import egcd as egcd
from common_rsa_functions import modinv as modinv
from RSAObject import RSAObject
from fractions import gcd
from sage.all_cmdline import *
from RSAExploits.rsa import *
from Exploit import Exploit

primes_seen = []

class Common_Modulus_Factor(Exploit):

    def run(self, ciphertexts):
        for i in range(0, len(ciphertexts) - 1):
            for j in range(1, len(ciphertexts)):
                factored = common_factor_exploit(ciphertexts[i], ciphertexts[j])
                for ciphertext in factored:
                    ciphertext.setM(ciphertext.decrypt())

# Check if the moduli used to encrypt 2 ciphertexts have a common factor
# If so, this function will attempt to recover the private exponent
# used for decryption. Returns a list of ciphertexts that can now be
# decrypted.
def common_factor_exploit(c1, c2):
    
    global primes_seen

    factored = []
    p = long(gcd(c1.getN(), c2.getN()))
    if p == 1:
	    return factored

    q1 = long(c1.getN() / p)
    q2 = long(c2.getN() / p)
    
    if (p in primes_seen or p in Primes()) and (q1 in primes_seen or q1 in Primes()):
        primes_seen.append(p)
        primes_seen.append(q1)
        totient = (p- 1) * (q1 - 1)
        c1.setD(long(modinv(c1.getE(), totient)))
        c1.setP(p)
        c1.setQ(q1)
        factored.append(c1)

    if (p in primes_seen or p in Primes()) and (q2 in primes_seen or q2 in Primes()):
        primes_seen.append(p)
        primes_seen.append(q1)
        totient = (p- 1) * (q2 - 1)
        c2.setD(long(modinv(c2.getE(), totient)))
        c2.setP(p)
        c2.setQ(q2)
        factored.append(c2)

    return factored

