from Crypto.PublicKey import RSA
import binascii # for testing
import fractions 
import random

class rsaData:
	def __init__(self, rsaobj, txt=None):
		self.rsaobj = rsaobj
		if txt !=None:
			self.txt  = txt
	
	def encrypt(self):
		if self.txt.m != None:
			self.txt.c = self.rsaobj.encrypt(long(self.txt.m), 1L)	
			return self.txt.c
		else:
			print "No plaintext in RSA data."		
	def decrypt(self):
		if self.txt.c != None:
			self.txt.m = self.rsaobj.decrypt(self.txt.c)	
			return self.txt.m
		else:
			print "No ciphertext in RSA data."


def rsaObj(N,e,d=None,p=None,q=None):	
	if N != None and e != None and d == None and p == None and q == None:
		key = RSA.construct((N, e))
	elif N != None and e != None and d != None and p == None and q == None:
		p, q = RecoverPrimeFactors(N, e, d)		
		key = RSA.construct((N, e, d, p, q))
	elif N != None and e != None and d != None and p != None and q == None:				
		key = RSA.construct((N, e, d, p, N//p))	
	elif N != None and e != None and d != None and p != None and q == None:
		key = RSA.construct((N, e, d, p))
	elif N != None and e != None and d != None and p != None and q != None:
		key = RSA.construct((N, e, d, p, q))
	
	return key	

class txt:
    def __init__(self,c,m=None,idnum=None,):
        self.c = c
        self.idnum = idnum
        if m != None:
            self.m = m

 
def failFunction():
	print("Prime factors not found")
 
def outputPrimes(a, n):
	p = fractions.gcd(a, n)
	q = int(n / p)
	if p > q:
		p, q = q, p
	return p,q
 
 
def RecoverPrimeFactors(n, e, d):
	"""The following algorithm recovers the prime factor
		s of a modulus, given the public and private
		exponents.
		Function call: RecoverPrimeFactors(n, e, d)
		Input: 	n: modulus
				e: public exponent
				d: private exponent
		Output: (p, q): prime factors of modulus"""
 
	k = d * e - 1
	if k % 2 == 1:
		failFunction()
		return 0, 0
	else:
		t = 0
		r = k
		while(r % 2 == 0):
			r = int(r / 2)
			t += 1
		for i in range(1, 101):
			g = random.randint(0, n) # random g in [0, n-1]
			y = pow(g, r, n)
			if y == 1 or y == n - 1:
				continue
			else:
				for j in range(1, t): # j \in [1, t-1]
					x = pow(y, 2, n)
					if x == 1:
						p, q = outputPrimes(y - 1, n)
						return p, q
					elif x == n - 1:
						continue
					y = x
					x = pow(y, 2, n)
					if  x == 1:
						p, q = outputPrimes(y - 1, n)
						return p, q


'''
#Test
key = RSA.generate(1024)

k = rsaObj(key.n,key.e,key.d,key.p)
s = "abcd"
i = int(s.encode("hex"),16)

td = txt(None,i)
d = rsaData(k,td)
c = d.encrypt()
print c
p = d.decrypt()
 
print p
print binascii.unhexlify(hex(p)[2:-1])
print d.txt.c
print d.txt.m
 
print k.p
print key.n == k.p*k.q
'''
